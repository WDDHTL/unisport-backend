# 登录接口测试说明

## 接口概述

**接口路径**: `POST /api/auth/login`

**功能描述**: 用户通过账号和密码登录系统，登录成功后返回JWT Token和用户基本信息

## 业务流程

```mermaid
graph TD
    A[前端发起登录请求] --> B[后端接收请求参数]
    B --> C[根据账号查询用户信息]
    C --> D{用户是否存在?}
    D -->|不存在| E[返回错误: 账号或密码错误]
    D -->|存在| F[检查账号状态]
    F --> G{账号是否正常?}
    G -->|已禁用| H[返回错误: 账号已被禁用]
    G -->|正常| I[BCrypt验证密码]
    I --> J{密码是否正确?}
    J -->|错误| K[返回错误: 账号或密码错误]
    J -->|正确| L[生成JWT Token]
    L --> M[构建返回数据]
    M --> N[返回Token和用户信息]
```

## 核心功能点

### 1. 密码验证机制
- **加密算法**: BCrypt（自动加盐，每次加密结果不同）
- **验证方式**: 使用 `BCrypt.checkpw()` 方法比对明文密码和加密密码
- **安全性**: 不可逆加密，即使数据库泄露也无法还原原始密码

### 2. JWT Token生成
- **算法**: HMAC-SHA256
- **载荷内容**:
  - `userId`: 用户ID
  - `account`: 用户账号
  - `iat`: 签发时间
  - `exp`: 过期时间（7天）
- **密钥**: 从 `application.properties` 读取 `jwt.secret`
- **过期时间**: 默认604800000毫秒（7天）

### 3. 返回数据结构
```json
{
  "code": 200,
  "message": "登录成功",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "user": {
      "id": 1,
      "nickname": "张三",
      "avatar": "https://example.com/avatar.jpg"
    }
  }
}
```

## 测试前提条件

### 1. 数据库准备
确保数据库中存在测试用户，可以使用注册接口创建，或手动插入：

```sql
-- 插入测试用户（密码: 123456）
INSERT INTO users (account, password, nickname, school, department, student_id, status, deleted) 
VALUES (
    '2024001', 
    '$2a$10$abcdefghijklmnopqrstuv...', -- BCrypt加密后的密码
    '张三',
    '清华大学',
    '计算机系',
    '2024001001',
    1,
    0
);
```

**注意**: 密码需要使用BCrypt加密，可以通过注册接口生成，或使用在线工具加密。

### 2. 服务启动
```bash
mvn spring-boot:run
```

访问API文档验证服务是否正常: http://localhost:8080/doc.html

## 测试用例

### 测试用例1: 正常登录（成功场景）

**请求地址**: `POST http://localhost:8080/api/auth/login`

**请求Header**:
```
Content-Type: application/json
```

**请求Body**:
```json
{
  "account": "2024001",
  "password": "123456"
}
```

**预期响应**:
```json
{
  "code": 200,
  "message": "登录成功",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEsImFjY291bnQiOiIyMDI0MDAxIiwiaWF0IjoxNzAxNjAwMDAwLCJleHAiOjE3MDIyMDQ4MDB9.xxxxxxxxxxxxxxxxxxxxx",
    "user": {
      "id": 1,
      "nickname": "张三",
      "avatar": null
    }
  }
}
```

**cURL命令**:
```bash
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"account":"2024001","password":"123456"}'
```

---

### 测试用例2: 账号不存在（失败场景）

**请求Body**:
```json
{
  "account": "notexist",
  "password": "123456"
}
```

**预期响应**:
```json
{
  "code": 40003,
  "message": "账号或密码错误，请检查后重试",
  "data": null,
  "timestamp": 1701667200000
}
```

**cURL命令**:
```bash
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"account":"notexist","password":"123456"}'
```

---

### 测试用例3: 密码错误（失败场景）

**请求Body**:
```json
{
  "account": "2024001",
  "password": "wrongpassword"
}
```

**预期响应**:
```json
{
  "code": 40003,
  "message": "账号或密码错误，请检查后重试",
  "data": null,
  "timestamp": 1701667200000
}
```

**cURL命令**:
```bash
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"account":"2024001","password":"wrongpassword"}'
```

---

### 测试用例4: 账号已被禁用（失败场景）

**前提**: 先将测试账号状态设置为禁用
```sql
UPDATE users SET status = 0 WHERE account = '2024001';
```

**请求Body**:
```json
{
  "account": "2024001",
  "password": "123456"
}
```

**预期响应**:
```json
{
  "code": 40004,
  "message": "您的账号已被禁用，如有疑问请联系管理员",
  "data": null,
  "timestamp": 1701667200000
}
```

**cURL命令**:
```bash
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"account":"2024001","password":"123456"}'
```

**恢复账号状态**:
```sql
UPDATE users SET status = 1 WHERE account = '2024001';
```

---

### 测试用例5: 参数校验 - 账号为空（失败场景）

**请求Body**:
```json
{
  "account": "",
  "password": "123456"
}
```

**预期响应**:
```json
{
  "code": 400,
  "message": "账号不能为空",
  "data": null
}
```

---

### 测试用例6: 参数校验 - 密码为空（失败场景）

**请求Body**:
```json
{
  "account": "2024001",
  "password": ""
}
```

**预期响应**:
```json
{
  "code": 400,
  "message": "密码不能为空",
  "data": null
}
```

---

### 测试用例7: Token验证（验证Token有效性）

**步骤1**: 先成功登录获取Token
```bash
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"account":"2024001","password":"123456"}'
```

**步骤2**: 复制返回的Token，在后续需要认证的接口中使用
```bash
# 假设后续有一个需要认证的接口 /api/users/me
curl -X GET http://localhost:8080/api/users/me \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

## 使用Knife4j测试

1. 启动项目后访问: http://localhost:8080/doc.html
2. 找到"认证授权模块" -> "用户登录"
3. 点击"调试"按钮
4. 输入测试参数：
   ```
   account: 2024001
   password: 123456
   ```
5. 点击"发送"按钮
6. 查看响应结果，复制返回的Token
7. 在页面顶部找到"文档管理" -> "全局参数设置"
8. 添加Header参数：
   - 参数名: `Authorization`
   - 参数值: `Bearer <你的Token>`
   - 参数类型: `header`
9. 现在可以测试其他需要认证的接口了

## 错误码说明

| 错误码 | 错误信息 | 说明 |
|--------|---------|------|
| 200 | 登录成功 | 登录成功 |
| 400 | 参数校验失败 | 账号或密码为空等参数错误 |
| 40003 | 账号或密码错误，请检查后重试 | 账号不存在或密码错误 |
| 40004 | 您的账号已被禁用，如有疑问请联系管理员 | 账号状态为禁用 |
| 50000 | 登录失败，系统异常，请稍后重试 | 服务器异常 |

> **详细的错误处理机制和前端对接指南，请参考**: [登录错误处理机制说明.md](./登录错误处理机制说明.md)

## 安全建议

### 1. 生产环境配置
- 修改 `jwt.secret` 为更复杂的密钥（至少32字符）
- 根据实际需求调整Token过期时间
- 启用HTTPS，防止Token在传输过程中被窃取

### 2. 防暴力破解
- 添加登录失败次数限制（如3次失败后锁定账号5分钟）
- 添加验证码机制（登录失败2次后要求输入验证码）
- 使用Redis记录登录失败次数

### 3. Token管理
- 前端将Token存储在localStorage或sessionStorage
- 每次请求在Header中携带Token: `Authorization: Bearer <token>`
- Token过期后引导用户重新登录
- 考虑实现Token刷新机制（RefreshToken）

### 4. 日志监控
- 记录所有登录尝试（成功和失败）
- 监控异常登录行为（如短时间内大量失败尝试）
- 定期审查登录日志

## 常见问题

### Q1: Token过期后如何处理？
**A**: 前端在请求接口时，如果返回Token过期错误，应该清除本地Token，并引导用户重新登录。

### Q2: 密码错误但提示"账号或密码错误"，能否明确提示？
**A**: 出于安全考虑，不应该明确提示是账号错误还是密码错误，否则攻击者可以通过返回信息判断账号是否存在。

### Q3: 如何实现"记住我"功能？
**A**: 可以通过延长Token过期时间实现，或实现RefreshToken机制（短期AccessToken + 长期RefreshToken）。

### Q4: 是否支持多设备同时登录？
**A**: 当前实现支持多设备登录，每次登录都会生成新的Token。如需限制单设备登录，可以在Redis中记录用户最新Token，并在拦截器中验证。

## 验证清单

- [ ] 正常登录成功，返回Token和用户信息
- [ ] 账号不存在时返回错误提示
- [ ] 密码错误时返回错误提示
- [ ] 账号被禁用时返回错误提示
- [ ] 参数校验正常（账号和密码为空时拦截）
- [ ] Token生成正确，可以被解析
- [ ] Token包含正确的用户ID和账号信息
- [ ] 日志记录完整（登录请求、成功、失败都有日志）
- [ ] 性能测试：并发登录响应时间在可接受范围内

## 总结

用户登录接口是整个系统的认证入口，必须确保：
1. **安全性**: 密码加密存储，Token机制安全
2. **可靠性**: 异常处理完善，错误提示友好
3. **可维护性**: 代码结构清晰，注释完整
4. **可扩展性**: 预留扩展空间（如增加验证码、多因素认证等）

请按照测试用例逐一验证，确保所有场景都能正常工作。
